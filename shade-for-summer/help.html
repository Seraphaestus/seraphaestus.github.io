<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Shade for Summer</title>
		<base href="https://seraphaestus.github.io/shade-for-summer/index.html"/>
		
		<link rel="stylesheet" type="text/css" href="./styles.css"/>
		<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism-twilight.min.css" rel="stylesheet" />
		
		<!-- For html reuse -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	</head>
	
	<body>
		<header></header>
		<script>$.get("components/header.html", function(data){ $("header").append(data); });</script>
		
		<div class="content">
			Shade for Summer features an in-browser shader editor for convenience and to verify that the image was actually generated by shader.<br>
			The code you write is compiled as a GLSL fragment shader, with some minor conveniences inspired by Godot Shading Language.
			<div class="editor language-glsl" style="min-width:0; min-height:0; width: fit-content; margin: 0.5em 0 0.5em 0;">//The main function is run on each pixel of the canvas, so each pixel has to be able to derive its color individually
void main() {
	// COLOR is an alias of gl_FragColor, and is what you need to set to actually output colors to the canvas
	// It's a 4D vector with components RGB and A for color and transparency, ranging from 0.0 to 1.0
	COLOR = vec4(1.0, 0.0, 1.0, 1.0);
	
	// RATIO represents uv values from (0, 0) at the top-left of the canvas to (1, 1) at the bottom-right of the canvas
	COLOR.rgb = vec3(RATIO, 1.0);
	// COORD represents aspect-normalized uv values, with the width stretched from the center to be proportionate to the height
	COLOR.xy = COORD;
	// TIME represents the number of seconds since the page was loaded
	COLOR.a = (sin(TIME) + 1.0) / 2.0;
	
	// Constants for pi (3.141..), tau (2 pi), and euler's number (2.718..)
	vec3 example = vec3(PI, TAU, E);
}</div>
			Additionally, precision specifiers are not needed as float values are set to mediump.<br>
			Here is a simple shader showcasing GLSL syntax and some useful techniques:
			
			<div class="editor language-glsl" style="min-width:0; min-height:0; width: fit-content; margin: 0.5em 0 0.5em 0;">// Uniforms can be declared to pass constants into the shader
// When used with supported types, input fields (e.g. checkbox, slider) will be autogenerated for you to tweak parameters outside of code
// The following types have support for external input fields: bool, float, and vec3 (as color)
uniform float circle_radius;
uniform vec3 circle_color;

// We can use floats to represent boolean values: 1.0 for true, 0.0 for false
// This is more flexible and efficient than using non-constant bool types
float is_in_circle(vec2 uv, vec2 center, float radius) {
	vec2 distance_to_center = distance(uv, center);
	
	// The step function discriminates a boundary. step(a, b) = 1.0 when a <= b, and 0.0 otherwise
	// You can think of this as like a sorting function: 1.0 if the inputs are in the correct order, else 0.0
	return step(distance_to_center, circle_radius);
}

void main() {
	COLOR = vec4(0.0, 0.0, 0.0, 1.0);
	
	float is_in_circle = is_in_circle(COORD, vec2(0.5), circle_radius);
	
	// The mix function linearly interpolates between two inputs. mix(a, b, 0.5) = halfway between a and b 
	// When the interpolater is exclusively 0.0 or 1.0, it functions as a selector: a if true else b
	COLOR.rgb = mix(COLOR.rgb, circle_color, is_in_circle);
}</div>
	</div>
		
		<!-- CodeJar scripts -->
		<script type="module" id="code">
			import {CodeJar} from "https://medv.io/codejar/codejar.js?"
			
			for (let codeSection of document.querySelectorAll(".editor")) {
				let codeJar = new CodeJar(codeSection, el => Prism.highlightElement(el));
				//setTimeout(() => { codeSection.contenteditable = "false";}, 1000);
			}
			
		</script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-core.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>

	</body>
</html>