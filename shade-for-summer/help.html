<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<title>Help - Shade for Summer</title>
		
		<base href="https://seraphaestus.github.io/shade-for-summer/index.html"/>
		
		<link rel="stylesheet" type="text/css" href="./styles.css"/>
		<style>
			a[href="./help.html"] {
				font-weight: bold;
			}
			.editor {
				width: inherit; /*fit-content;*/
				min-width: 0;
				min-height: 0;
				margin: 0.5em 0 0.5em 0;
			}
		</style>
		
		<!-- For html reuse -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	</head>
	
	<body>
		<header></header>
		<script>$.get("components/header.html", function(data){ $("header").append(data); });</script>
		
		<div class="content page">
			Shade for Summer features an in-browser shader editor for convenience and to verify that the image was actually generated by shader.<br>
			It also comes with explanatory tooltips when you hover over elements of code!<br>
			The code you write is compiled as a GLSL fragment shader, with some minor conveniences inspired by Godot Shading Language.
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips">// Comments can be written by prepending a line with // or enclosing a section in /* ... */
/* Comments typically document code, so it can be helpful to scan ahead to any inline comments as you try to parse the code */
// You can also use them to "comment out" sections of code to temporarily disable them, as comments don't affect the code at all:
//const float disabled = 1.0;

// Every shader must have a "main" function. Functions contain runnable code, and the program starts by running the code in main()
void main() {
	// All statements of code must end in a semicolon, to delineate them as they don't necessarily have to be on seperate lines
	;
	
	// Variables can be defined to store values/data of different types, which lets you reuse them and reference them by a meaningful label
	float f; // A float is the main type of variable you'll be working with. It stores any rational/decimal number, e.g. 1.0 or 2.5
	         // You must write float values like 1.0 with the decimal point, else the compiler will assume it's an integer-only type
	float f2 = 1.0; // You can set an initial value
	f = f2 + 3.0;   // or set the value of an already-declared variable
	// Note that "=" means assignment, not equality like in maths; setting the variable on the left to the value of the expression on the right
	
	// Variables can be manipulated with various different operators
	f += 1.0;
	f *= 2.0;
	f = f / (2.0 + 3.0);
	
	
	// A vector is multiple floats wrapped into one object, which can represent e.g. a coordinate or a color
	vec3 v     = vec3(1.0, 2.0, 3.0); // These components (up to 4 max) are called x, y, z, and w
	vec3 color = vec3(1.0, 0.5, 0.8); // For colors they can also be referenced as r, g, b, and a (for "alpha")
	
	f = (color.r + color.g + color.b) / 3.0; // You can access the individual components of the vector
	vec2 v2 = v.yz; 												 // Even multiple at once, in any order, which is called swizzling
	
	vec3 v3 = vec3(v2, 0.0); // You can also create vectors from other vectors, e.g. a 3D vector using a 2D vector and a float
	v = v * 1.5 + f; // Applying an operation to a vector with a float will apply it to all components at once
	f = distance(v, v3) + length(v) + dot(v, v3); // There are also built-in functions you can call for certain vector-specific operations
	
	
	// The following types are also available:
	bool b; // Represents a boolean value that can be true or false. These can be used with if statements.
	mat3 m; // Represents a matrix, i.e. a n-by-n array of floats. These can be used to transform vectors.
	int n;  // Represents an integer value that can only be whole numbers. Can be used for exact precision, but floats will usually suffice.
	f += float(n); // In order to mix float and int types, you have to explicitly convert it first
	
	
	// If statements can be used to run code conditionally. See below for better alternatives.
	if (b == true || b != !true || f > 0.5 && f <= 0.75) { 
		// This should be read: "If b is true OR b isn't not-true OR (f is greater-than 0.5 AND f is less-than-or-equal-to 0.75)
		// Code in here will run only if the above condition is satisfied
	}
	if (b) {
		// Run code here if b is true
	} else {
		// Otherwise run code here
	}
	
	
	// For loops can be used to run code iteratively multiple times
	for (int i = 0; i < 6; i += 1) {
		// Code in here will run 6 times, with the value of i changing from 0 to 5 (inclusive), incrementing by 1 each time.
	}
	// Using floats as the iterator can be more convenient, as it means you don't have to convert the variable type each time you use it 
	for (float j = 0.0; j <= 6.0; j += 1.0) {
		if (i < 4) { 
			// On iterations 0-3, it will run into the continue statement and skip the rest of the code, jumping to the next iteration
			continue;
		}
		if (i > 3) { 
			// On iterations 4-6, code that gets to this point will cause the loop to exit, skipping all further iterations
			break;
		}
	}
}</div></div>
			Additionally for advanced users, float values are set to mediump (medium precision).<br>
			Read more on <a href="https://learnwebgl.brown37.net/12_shader_language/glsl_data_types.html" style="text-decoration-line: underline;">data types</a> or <a href="https://learnwebgl.brown37.net/12_shader_language/glsl_control_structures.html" style="text-decoration-line: underline;">control structures</a> in GLSL<br><br>
			
			In order to get input and output from your code, there are several built-in variables you can read from and/or write to:
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips">// The main function is run for each pixel of the canvas to set its color
// This means the code must derive the color of each pixel with no context of other pixels, using maths
void main() {
	// You need to set the COLOR built-in to actually output colors to the canvas
	// It's a 4D vector with components RGB and A for color and transparency ("alpha"), ranging from 0.0 to 1.0
	COLOR = vec4(1.0, 1.0, 1.0,   1.0);
	
	// The components of 4D vectors can be accessed with .xyzw or interchangably with .rgba
	COLOR.rgb = vec3(1.0, 0.0, 1.0); // This works for both getting *and* setting multiple components at once
}</div></div>
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips flag-interactive">// Edit me, I'm interactive!
void main() {
	// RATIO gives the position of the pixel as a ratio of the width and height of the canvas
	// Ranging from vec2(0.0, 0.0) at the top-left to vec2(1.0, 1.0) at the bottom-right
	float gradient = RATIO.x;
	// When the rgb components are equal, the resulting color is grayscale
	COLOR = vec4(gradient, gradient, gradient, 1.0);
}</div></div>
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips flag-interactive">void main() {
	// Just a little maths can produce pretty results!
	COLOR = vec4(1.0 - RATIO.x,  RATIO.y,  RATIO.x,  1.0);
}</div></div>
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips flag-interactive">void main() {
	// RATIO will appear stretched, as 100% of the width is not the same distance as 100% of the height
	// COORD gives an adjusted version of RATIO that nullifies this stretching accordingly
	// Ranging from vec2(-0.25, 0.0) at the top-left to (1.25, 1.0) at the bottom right
	
	vec2 uv = COORD; // "uv" is the conventional way to refer to coordinates on a texture
	float horizontal_lines = cos(uv.x * TAU * 4.0);
	float vertical_lines   = cos(uv.y * TAU * 4.0);
	
	COLOR.rgb = vec3(horizontal_lines, 0.0, vertical_lines);
	COLOR.a = 1.0;
}</div></div>
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips flag-interactive">void main() {
	COLOR.rgb = vec3(0.5, 0.3, 0.5);
	
	// TIME lets you vary the canvas over time
	// This can be used for debugging or creating animated effects for fun
	float time_in_seconds = TIME;
	
	// You can also use these mathematical constants
	vec3 constants = vec3(PI, TAU, E);
	
	// The period of sin is TAU, so this will increment by half that every second, i.e. loop every 2s
	float loop = sin(time_in_seconds * PI);
	loop = (loop + 1.0) / 2.0; // Transform from [-1, 1] range to [0, 1]
	COLOR.a = loop;
}</div></div>
			<br>
			Here is an example of a simple shader. Try playing around with the code to see how it works.
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips flag-interactive" data-uniforms="circle_radius:0.4;circle_color:#ff006f;">// Uniforms can be declared to pass constants into the shader
// When used with supported types, input fields (e.g. checkbox, slider) will be autogenerated for you to tweak parameters outside of code
uniform float circle_radius #range(0, 0.5); // The #range hint specifies a slider's range (default 0-1), and optionally step (default 0.01)
uniform vec3 circle_color #color; // The #color hint specifies that the vec3 should use a color picker instead of sliders

// Arbitrary functions can be created, which lets you reuse code and reference it by a meaningful label
// First the type of the return value is declared. Then the function is given a name ("opaque") to call it by
// Then in brackets the input values are declared, giving them types and names by which to reference them within the function
vec4 opaque(vec3 color) {
	return vec4(color, 1.0);
}

bool is_in_circle(vec2 uv, vec2 center, float radius) {
	// A circle is defined by all points whose distance to the center is less than the radius
	float distance_to_center = distance(uv, center);
	// Returns true if distance_to_center <= circle_radius else false
	return distance_to_center <= circle_radius;
}

void main() {
	vec3 black = vec3(0.0);
	
	// Calling a function we defined earlier
	bool in_circle = is_in_circle(COORD, vec2(0.5), circle_radius);
	
	if (in_circle) {
		COLOR = opaque(circle_color);
	} else {
		COLOR = opaque(black);
	}
}</div></div>
			<br>
			Here is the same shader rewritten using some slightly more advanced techniques
			<div class="codejar-wrap"><div class="editor language-glsl flag-tooltips flag-interactive" data-uniforms="circle_radius:0.4;circle_color:#ff4d00;">uniform float circle_radius #range(0, 0.5);
uniform vec3 circle_color #color;

// We can use floats to represent boolean values: 1.0 for true, 0.0 for false
// This is more flexible as you can work with them using maths without having to convert
// It's also more efficient on the GPU than branching code, though it doesn't really matter on this level of program
float is_in_circle(vec2 uv, vec2 center, float radius) {
	float distance_to_center = distance(uv, center);
	
	// Returns 1.0 if distance_to_center <= circle_radius else 0.0
	return step(distance_to_center, circle_radius);
}

void main() {
	COLOR = vec4(vec3(0.0), 1.0);
	
	float in_circle = is_in_circle(COORD, vec2(0.5), circle_radius);
	
	// The mix function can be used to select between two values
	// This is because linearly interpolating by 0% or 100% just takes you to either input
	COLOR.rgb = mix(COLOR.rgb, circle_color, in_circle);
}</div></div>
			<a href="./code.html" style="background-color:#b1998b; color:black; display:inline-block; padding:0.6em 2em; margin:4px 2px; margin-bottom:10px; font-size:20px; font-weight:600; position:relative; left:50%; translate:-50% 0;">Go to Code Playground</a>
		</div>
		
		<script type="text/javascript" src="scripts/webgl-utils.js"></script>
		<script type="text/javascript" src="scripts/canvas.js"></script>
		<script type="text/javascript" src="scripts/shader-editor.js"></script>
		
		<!-- Code Tooltips scripts -->
		<script type="text/javascript" src="scripts/text-utils.js"></script>
		<script type="text/javascript" src="scripts/code-tooltips.js"></script>
		
		<!-- CodeJar scripts -->
		<script type="text/javascript" src="scripts/init-codejar.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-core.min.js"></script>
		<script type="module" id="code">
			import {CodeJar} from "https://medv.io/codejar/codejar.js?"
			import {withLineNumbers} from 'https://medv.io/codejar/linenumbers.js';
			
			initCodeEditors(CodeJar, withLineNumbers);
		</script>

	</body>
</html>