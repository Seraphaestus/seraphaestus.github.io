<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<title>Help - Shade for Summer</title>
		
		<base href="https://seraphaestus.github.io/shade-for-summer/index.html"/>
		
		<link rel="stylesheet" type="text/css" href="./styles.css"/>
		<style> a[href="./help.html"] { font-weight: bold; } </style>
		
		<!-- For html reuse -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	</head>
	
	<body>
		<header></header>
		<script>$.get("components/header.html", function(data){ $("header").append(data); });</script>
		
		<div class="content page">
			Shade for Summer features an in-browser shader editor for convenience and to verify that the image was actually generated by shader.<br>
			It also comes with explanatory tooltips when you hover over elements of code!<br>
			The code you write is compiled as a GLSL fragment shader, with some minor conveniences inspired by Godot Shading Language.
			<div class="codejar-wrap"><div class="editor language-glsl" style="min-width:0; min-height:0; width: fit-content; margin: 0.5em 0 0.5em 0;">// Comments can be written by prepending a line with // or enclosing a section in /* ... */
/* They can help label what parts of your code is doing, and do not affect the code at all */
//const float test = 1.0; You can also use them to "comment out" sections of code to temporarily disable them

// Every shader must have a "main" function, which code can be written inside
void main() {
	// All statements of code must end in a semicolon. You can put multiple on the same line but it's best practice to split them for clarity
	;
	// Variables can be defined to store values of different types for reuse, which also lets you give them a meaningful label for clarity
	float f; // A float is the main type of variable you'll be working with. It stores any rational/decimal number, e.g. 1.0 or 2.5
	         // You must write float values like 1.0 with the decimal point, else the compiler will assume it's an integer-only type
	float f2 = 1.0; // You can set an initial value
	f = f2 + 3.0;   // or set the value of an already-declared variable
	
	f += 1.0;
	f *= 2.0;
	f = f / (2.0 + 3.0);
	
	vec3 v = vec3(1.0, 2.0, 3.0); // A vector is multiple floats wrapped into one object, which can represent e.g. a coordinate or a color
	f += v.x;       // You can get the individual components of the vector
	vec2 v2 = v.xz; // Even multiple at once, in any order, which is called swizzling
	vec3 v3 = vec3(v2, 0.0); // You can also create vectors from other vectors, e.g. a 3D vector using a 2D vector and a float
	v = f * v + 2.0; // Applying an operation to a vector with a float will apply it to all components at once
	f = distance(v, v3) + length(v) + dot(v, v3); // There are also built-in functions you can call for certain vector-specific operations
	
	// The following types are also available:
	bool b; // Represents a boolean value that can be true or false
	mat3 m; // Represents a matrix, i.e. a n-by-n array of floats
	int n;  // Represents an integer value that can only be whole numbers.
	f += float(n); // In order to mix float and int types, you have to explicitly convert it first
	
	// If statements can be used to run code conditionally. See below for better alternatives.
	if (b == true || b != !true || f > 0.5 && f <= 0.75) { 
		// This should be read: "If b is true OR b isn't not-true OR (f is greater-than 0.5 AND f is less-than-or-equal-to 0.75)
		// Code in here will run only if the above condition is satisfied
	}
	
	// For loops can be used to run code iteratively multiple times
	for (int i = 0; i < 6; i += 1) {
		// Code in here will run 6 times, with the value of i changing from 0 to 4, incrementing by 1 each time.
		if (i == 4) { continue; } // On the 4th iteration, it will run into the continue statement and skip to the 5th iteration
		if (i > 3) { break; }     // On the 4th and every subsequent iteration, code that gets to this point will cause the loop to exit
	}
	// Using floats as the iterator can be more convenient, even with integer iteration, as it means you don't have to convert the variable type each time you use it 
	for (float j = 0.0; j < 5.0; j += 1.0) {
	}
}</div></div>
			Additionally, precision specifiers are not needed as float values are set to mediump.<br>
			Read more on <a href="https://learnwebgl.brown37.net/12_shader_language/glsl_data_types.html" style="text-decoration-line: underline;">data types</a> or <a href="https://learnwebgl.brown37.net/12_shader_language/glsl_control_structures.html" style="text-decoration-line: underline;">control structures</a> in GLSL<br><br>
			
			In order to get input and output from your code, there are several built-in variables you can read from and/or write to:
			<div class="codejar-wrap"><div class="editor language-glsl" style="min-width:0; min-height:0; width: fit-content; margin: 0.5em 0 0.5em 0;">// The main function is run for each pixel of the canvas to set its color
// This means the code must derive the color of each pixel with no context of other pixels, using maths
void main() {
	// You need to set the COLOR built-in to actually output colors to the canvas
	// It's a 4D vector with components RGB and A for color and transparency, ranging from 0.0 to 1.0
	COLOR = vec4(1.0, 1.0, 1.0,   1.0);
	
	// The components of 4D vectors can be accessed with .xyzw or interchangably with .rgba
	COLOR.rgb = vec3(1.0, 0.0, 1.0);
	
	// RATIO and COORD give you the position of the pixel on the canvas, letting you differentiate them
	
	// e.g. To draw a gradient along the width of the canvas:
	COLOR = vec4(RATIO.x, RATIO.x, RATIO.x, 1.0);
	
	// e.g. To draw a grid across the canvas:
	float horizontal_lines = cos(COORD.x * TAU * 3.0);
	float vertical_lines = cos(COORD.y * TAU * 3.0);
	COLOR.rgb = vec3(1.0) * max(horizontal_lines, vertical_lines);
	
	// TIME lets you vary the canvas over time, useful here for debugging or creating animated effects for fun
	COLOR.a = (sin(TIME) + 1.0) / 2.0;
	
	// You can also use these constants
	vec3 constants = vec3(PI, TAU, E);
	COLOR.a = (sin(TIME * TAU) + 1.0) / 2.0;
}</div></div>
			<br>
			Here is a simple shader showcasing some useful techniques. Try copying it into the code playground to see how it works.
			<div class="codejar-wrap"><div class="editor language-glsl" style="min-width:0; min-height:0; width: fit-content; margin: 0.5em 0 0.5em 0;">// Uniforms can be declared to pass constants into the shader
// When used with supported types, input fields (e.g. checkbox, slider) will be autogenerated for you to tweak parameters outside of code
uniform float circle_radius #range(0, 0.5);
uniform vec3 circle_color #color;

// Arbitrary functions can be created in order to make code more readable and reusable
// When the function is called, different values can be passed in for each of the declared parameters, and it will evaluate to the return value
// First the type of the return value is declared - "void" if it doesn't return any value - then the function is given a name ("is_in_circle") to call it by
// Then in brackets the parameters the function takes are declared, giving them types and names by which to reference them within the function
float is_in_circle(vec2 uv, vec2 center, float radius) {
	float distance_to_center = distance(uv, center);
	// Returns 1.0 if distance_to_center <= circle_radius else 0.0
	return step(distance_to_center, circle_radius);
}

void main() {
	COLOR = vec4(0.0, 0.0, 0.0, 1.0);
	
	// We can use floats to represent boolean values: 1.0 for true, 0.0 for false
	// This is more flexible and efficient than using non-constant bool types
	float is_in_circle = is_in_circle(COORD, vec2(0.5), circle_radius);    // <---- Calling the function we declared above
	
	// When the interpolater of a mix function is exclusively 0.0 or 1.0, it functions as a selector: a if true else b
	COLOR.rgb = mix(COLOR.rgb, circle_color, is_in_circle);
}</div></div>
			<a href="./code.html" style="background-color: #b1998b; color: black; display: inline-block; padding: 0.6em 2em; margin: 4px 2px; font-size: 20px; font-weight: 600; position:relative; left:50%; translate:-50% 0;">Go to Code Playground</a>
			<br><br>
			Possible/planned features/TODO: 
			<ul>
				<li>Alternate syntax highlighting options</li>
				<li>Fix weird blurring on main index page</li>
				<li>Syntax highlighting not working properly on live</li>
			</ul>
		</div>
		
		<!-- Code Tooltips scripts -->
		<script type="text/javascript" src="scripts/text-utils.js"></script>
		<script type="text/javascript" src="scripts/code-tooltips.js"></script>
		
		<!-- CodeJar scripts -->
		<script type="module" id="code">
			import {CodeJar} from "https://medv.io/codejar/codejar.js?"
			
			for (let codeSection of document.querySelectorAll(".editor")) {
				let codeJar = new CodeJar(codeSection, el => Prism.highlightElement(el));
				// Not sure why it happens but this fixes a bug where 1 (one) of the editors refuses to highlight properly until you manually edit it
				codeJar.updateCode(codeJar.toString());
			}
		</script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/components/prism-core.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>

	</body>
</html>